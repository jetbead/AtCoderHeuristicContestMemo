# 局所探索/山登り/焼きなまし

## Links

- 誰でもできる焼きなまし法(gasin さん)
  - https://gasin.hatenadiary.jp/entry/2019/09/03/162613
- 焼きなまし法のコツ Ver. 1.3(shindannin さん)
  - https://shindannin.hatenadiary.com/entry/2021/03/06/115415
- 詳解 焼きなまし法(hakomo さん)
  - https://github.com/hakomo/Simulated-Annealing-Techniques
- 競技プログラミングにおいて焼きなまし法に堕ちずに落とすコツ(tsukammo さん)
  - https://qiita.com/tsukammo/items/b410f3202372fe87c919
- chokudai 先生の焼きなまし講座
  - https://togetter.com/li/607979
- 貪欲法、山登り法、焼きなまし、ビームサーチ、これらの間の関係について(kmyk さん)
  - https://kmyk.github.io/blog/blog/2019/03/07/local-search-and-greedy/
- 焼きなましをするときの設計に関するメモ(yunix_kyopro さん)
  - https://yunix-kyopro.hatenablog.com/entry/2022/10/30/141616
  - https://twitter.com/yunix91201367/status/1586588684622520322
- AHC典型解法シリーズ第2弾「焼きなまし法」(thunder さん)
  - https://qiita.com/thun-c/items/ecd438fde4d237b1f7bc
- 初心者から初心者に向けた焼きなましのすすめ(tombo さん)
  - https://tombo314.hatenablog.com/entry/2024/04/24/153457

## テンプレート

- [C++でのテンプレート](./cpp_template.md)

## 状態
(自明・非自明というのは、適当に自分の中での分類なので注意)

- 自明系
  - 盤面やグラフなど、問題の解空間をそのまま状態に持つ
  - 訪問点の順番(TSP系)
- 非自明系
  - 問題の解空間の一部だけ状態に持つ(残りは別途最適化)
  - 操作列をそのまま持つ
  - 訪問辺順番(TSP系)
  - 「解空間->状態空間->解空間」みたいな変換(復元)ができる場合、より性質の良い(探索空間の小さい)状態空間で探索する

### 状態の局所性

- 局所性
  - 状態内の離れた2つの要素に関連性(依存関係、文脈)がなければ、それぞれの要素は独立に考えることができる
  - 焼きなましは、「状態を少し変えて改善(局所探索)」という感じのため、近傍を考えるうえで重要
    - 状態の1つの要素を入れ替えるのが容易などであれば、それを近傍として局所探索/山登り/焼きなましができる
    - 2次元グリッドなどの問題の場合、部分的な領域で見るとそこだけを入れ替えて別の状態にできるなら近傍として利用できる

## 近傍

- 同じ焼きなまし解だとしても差がでる大きな要素
  - 近傍によって探索空間の形が変わるため、探索の質に直結する
- 「極小で高速な近傍」「依存する要素をまとめて置き換える近傍」など
- 近傍として望ましい条件にはいくつかありえるが、基本的には、良い状態間を行き来できるような近傍を考えられるか

### 変化量が小さな近傍

- 状態の変化(スコアの変化量)がとても小さい近傍のこと
  - 状態の1要素を他の要素と入れ替える、位置を1だけずらす、2つの要素をswapする、など
- 「一番小さい」と思っても、より変化量が小さい近傍が作れる可能性があるので、できるだけ検討する
  - 2-opt近傍
  - https://phyllo-algo.hatenablog.com/entry/2018/06/21/002545


### 確実に前進する近傍

- https://qiita.com/takapt0226/items/b2f6d1d77a034b529e21#%E9%81%B7%E7%A7%BB
- 1コンボを1回の遷移とする

### greedy 遷移 / 局所探索遷移

- 評価値が良くなるとは限らなくても、何らかgreedyな操作や局所探索を1回の遷移とする近傍
  - 多少の無駄な遷移が入っても、良い遷移が入っていればよい
- 対象を動かせなくなるまで動かす、部分破壊再構築などでランダムに再構築、など

### 無駄な遷移をなくす

- xy座標系(-10^6 <= x,y <= 10^6)とかのときに、1ずつずらすとかは無駄なので、点が存在するところ、接するところ、交点などだけに遷移する
  - 必ず評価値が変化する
- 「評価値が変わらない遷移」
  - 例えば、パスの長さがスコアのときなどに、パスに関係していない辺を変えてもスコアは変化しないが、繋ぎ変えなどでより長いパスにできたりする
  - どちらかというと、評価関数の方で考慮するような方法を考えるべき
- pertubation for tie-breaking
  - 同評価値の状態に対してランダムに選ぶのを変えたりなど摂動を与える

### 2-opt 近傍

- https://en.wikipedia.org/wiki/2-opt
- 巡回セールスマン問題などで、2 点を交換する 2-swap 近傍は 4 辺変化してしまうが、そこを 2 辺変化させるような近傍
- 実装方法にもよるが、訪問点の順を状態に持っている場合は、ある範囲を reverse する感じになる
  - O(N)程度かかる
  - (辺の付替え時に分離しないように付け替える必要があるが、その判定のためにO(N)で辺をたどる必要があるため)
    - https://twitter.com/hotpepsi/status/1509563061027610624
- その他
  - k-opt(3-opt, 4-opt, double-bridge)
  - Lin-Kernighan Heuristic

#### 類型

- 系列を3箇所で切ってそれぞれ系列A、系列B、系列C、系列Dとして、ACBDの順番で連結する
  - [AHC028](../ContestMemo/ahc028.md)

### kick 近傍

- 局所解を抜け出す(kick)ような状態を大きく変える近傍
- Introduction to Heuristics Contest 解説 p.7
  - https://img.atcoder.jp/intro-heuristics/editorial.pdf
- k-swap-kick
  - TSP などで、k 個のセグメント s1,s2,...,sk を s1,sk,...,s2 にする感じ
- 2-opt ではたどり着くのが難しいような double bridge みたいな形にキックする

### 部分破壊と再構築

- パスや状態の一部分を壊して再構築するような近傍
- https://togetter.com/li/607979?page=2
- パスやサイクルの一部を破壊してDFSで再構築
  - [AHC002](../ContestMemo/ahc002.md)
  - [AHC010](../ContestMemo/ahc010.md)
  - [AHC027](../ContestMemo/ahc027.md)
- 領域の一部を破壊して再構築
  - [AHC014](../ContestMemo/ahc014.md)
    - 解が操作列でも、盤面での部分領域に対応する部分列の削除＆後ろに操作列追加で近傍を作成可能
    - 操作列に注目しても、操作列の依存関係を有向グラフとしてトポロジカルソートすると操作列の途中から最後をまとめて削除、ということもできる
  - [AHC020](../ContestMemo/ahc020.md)
    - ある放送局の強度を0にして、カバーできなくなった家を適当な順番で最小コストでカバーする近傍
    - ある放送局の強度を上げて、順番にカバーできない家ができないように最小化する近傍
    - など
  

### Invalidな状態を許容する焼きなまし

- 解の条件を満たさない状態になることを許容することで、探索空間で推移が難しい状態に推移できやすくなる可能性がある
  - 最終状態では条件を満たす必要があるため、最後にチェックをしておいたほうが良い
  - 条件を満たさない場合はペナルティとして、時間に応じて徐々に強くしていく、など
- [AHC011](../ContestMemo/ahc011.md)
  - 最終的に「与えられたタイルで作れる」必要があるが、辺の追加・削除を近傍に、与えられたタイルで作れない状態も探索
    - ただし、評価関数は各利用タイル数の差にして0になるよう目指す

## 評価関数

- スコアをそのまま利用
- 避けたい状態に対してペナルティ
- [AHC011](../ContestMemo/ahc011.md)
  - 2タイルをswapする近傍で、「一番大きな木のサイズ」を評価関数にすると、それ以外のタイルの状態が考慮できないので、「連結成分の個数(が1になるようにする)」や「連結成分のサイズの2乗和」などにすると、収束が速い

### 高速だが正確ではない評価関数

- 「高速だが正確ではない評価関数」が作れる場合、探索回数を確保でき、よりよい解にたどり着ける可能性が高まる
- 正確ではない評価関数で探索し、その結果を初期値として、最後だけ正確な評価関数で探索する

## 時間に応じて近傍や評価関数を変える

- 時間に応じて、荒く→細かく探索する
  - 時間で区切って条件を変える
- 時間に応じて、徐々に正確にしていく、徐々に条件を満たすようにしていく
  - `alpha * eval1() + (1-alpha) * eval2()`的に混ぜる
  - 時間で区切って使う評価関数を変える

## 高速化

### 差分計算

- 近傍への遷移では、状態を一部分だけ変化させる場合が多く、スコアや評価関数の値をその差分だけ高速に計算できる場合がある
- [AHC012](../ContestMemo/ahc012.md)
  - 直線の追加削除は、その直線の両側の領域だけを考えれば良い
  - ある領域にある個数は座圧＋二次元累積和でO(1)で求められ、領域数はO(K)程度

### TSPのパスをdequeで持ちながらスコア計算

- TSPパスをdequeで持つ
  - 訪問マスをdequeで持って、front/backに対する操作のみ許す
- [AHC027](../ContestMemo/ahc027.md)

### 状態更新/判定処理を後に持っていくテク

- 「近傍に遷移(状態更新)してから評価関数の値を計算」ではなく「遷移後の評価関数の値を計算して移動すると判断した場合だけ状態を更新」する
- 評価関数の値を計算後にundo操作するとundo操作分の時間がかかってしまうが、状態更新前に評価関数が計算できる場合はundo操作を省略できる
- [AHC009](../ContestMemo/ahc009.md)
  - 前からDP・後からDPを持っておくと、差分計算が高速に求められる
  - さらに、近傍更新時の変更箇所をターン順方向に固定すると、状態更新の方も高速化可能
- [AHC024](../ContestMemo/ahc024.md)
  - 「色を変える→スコア計算→焼きなましの採用判定→採用されるなら連結性判定＆隣接判定」とすることで、結局rollbackするときに重い判定処理を省略できる

### 評価関数計算の打ち切り

- https://qiita.com/not522/items/cd20b87157d15850d31c
  - 変化量からしきい値以下か判定するところを式変形して、遷移先に依存しないところを先に計算しておくことで、評価関数内でしきい値を超えることがわかったタイミングで打ち切れるようになるテク

### exp()の計算部分を2^xの計算で近似して高速処理するテク

- http://spvyxgfbtewiazrl.doorblog.jp/archives/50676843.html
- https://twitter.com/koyumeishi_/status/1709456647285026819
- https://twitter.com/koyumeishi_/status/1721964004741136589

- 自分のコードの場合は、以下のようにする感じ？(＋温度調整)
```
if (exp(delta / T) >= frand()) {
↓
if (((uint32_t)(1) << (uint32_t)(32 + delta / T)) >= xor128()) {
```

## 状態の複数候補生成/サンプリング

- 焼きなまし中に出現する状態について、評価値が大きいものをいくつか保存しておくことで、状態のN-best的なものを用意できる
  - ただし、最終解の周辺だけとかになりそう(自己相関が高い)なので、多様性が必要だったら、他の手法や、評価値をサンプリング回数とか、別のサンプリング方法とかを検討
- https://ja.wikipedia.org/wiki/%E3%82%AE%E3%83%96%E3%82%B9%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AA%E3%83%B3%E3%82%B0
- [AHC030](../ContestMemo/ahc030.md)

## その他

### Successive Halving

- https://cyberagent.ai/blog/research/1036/


### その他のネタ

- https://twitter.com/chokudai/status/1672116955330011136
  - 「これまでの遷移の評価差分の絶対値の平均値」を最高温度に設定
